//
// Bomb.cpp for BOMB in /home/gouet_v/Rendu/semester4/CPP/cpp_indie_studio
// 
// Made by Victor Gouet
// Login   <gouet_v@epitech.net>
// 
// Started on  Thu Apr 28 16:25:11 2016 Victor Gouet
// Last update Fri Apr 29 13:51:38 2016 Victor Gouet
//

#include "../include/Abomb.hpp"
#include <iostream>
#include <unistd.h>

Abomb::Abomb() : AGameObject(irr::core::vector3df(0, 0, 0), "media/caisse")
{
  alive = true;
  use = false;
  (*this)->setVisible(false);
  threadBomb = new std::thread([&] {run(); });
  _power = 3;
}

Abomb::Abomb(Abomb const &other) : AGameObject(irr::core::vector3df(0, 0, 0), "media/caisse")
{
  *this = other;
}

Abomb	&Abomb::operator=(Abomb const &other)
{
  alive = true;
  use = false;
  (*this)->setVisible(false);
  threadBomb = new std::thread([&] {run(); });
  this->_power = other._power;
  return (*this);
}

Abomb::~Abomb()
{
  alive = false;
  use = true;
  condVar.notify_one();
  threadBomb->join();
  delete threadBomb;
}

// void			Abomb::willExplose()
// {
//   (*this)->setVisible(false);
// }

void				Abomb::run()
{
  while (alive)
    {
      std::unique_lock<std::mutex>	lk(_mutex);

      while (!use && alive)
	condVar.wait(lk);
      if (alive == false)
	{
	  lk.unlock();
	  return ;
	}
      (*this)->setVisible(true);
      sleep(3);
      if (!alive)
	return ;
      willExplose();      
      use = false;
    }
}


bool			Abomb::isAlive() const
{
  return (alive);
}

bool			Abomb::isUse() const
{
  return (use);
}

void			Abomb::operator<<(irr::core::vector3df const &pos)
{
  std::lock_guard<std::mutex> lock(_mutex);
  use = true;
  (*this)->setPosition(pos);
  condVar.notify_one();
}
